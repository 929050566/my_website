# 真正了解 Go 的 GC 机制

## 什么是 GC？

垃圾回收（Garbage Collection，缩写为 GC），是一种自动内存管理机制。

即我们在程序中定义一个变量后，会在内存中开辟相应空间进行存储。当不需要此变量后，需要手动销毁此对象，并释放内存。而这种对不再使用的内存资源进行自动回收的功能即为垃圾回收。

---

## GC 相关术语

### 赋值器
说白了就是你写的程序代码，在程序的执行过程中，可能会改变对象的引用关系，或者创建新的引用。

### 回收器
垃圾回收器的责任就是去干掉那些程序中不再被引用的对象。

### STW
全称是 **Stop The World**，GC 期间某个阶段会停止所有的赋值器，中断你的程序逻辑，以确定引用关系。

举个例子，有一个大院，孩子特别多，老师希望他们以班长为起点手牵手在一起，但总有几个不听话的孩子，没有牵手。为了找出这些不听话的孩子，你会以班长为起点，一个一个地往后捋。

但是如果有一个名叫张三的孩子，之前在队尾，后来在你数到队伍中间的时候，又跑到了队头和班长牵手去了。当你数完后，因为没有统计到张三，你就认为张三没有听话，没有奖励小红花，岂不让孩子比窦娥还冤。所以这种情况下，你需要先让孩子们不动（映射到程序的概念，即 STW 停止程序运行），然后再统计。

### Root 对象
根对象是指赋值器不需要通过其他对象就可以直接访问到的对象。通过 Root 对象，可以追踪到其他存活的对象。

常见的 Root 对象有：
- **全局变量**：程序在编译期就能确定的那些存在于程序整个生命周期的变量。
- **执行栈**：每个 `goroutine`（包括 `main` 函数）都拥有自己的执行栈，这些执行栈上包含栈上的变量及堆内存指针。（堆内存指针即在 `goroutine` 中申请或者引用了在堆内存的变量）

---

## Go 的 GC 发展演变史

### v1.3 - 标记清除法

标记清除法主要包含两个步骤：
1. **标记**
2. **清除**

#### 示例：
1. 开启 STW，停止程序的运行，图中是本次 GC 涉及到的 Root 节点和相关对象。

   ![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.001.jpeg)

2. 从根节点出发，标记所有可达对象。

   ![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.002.jpeg)

3. 停止 STW，然后回收所有未被标记的对象。

   ![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.003.jpeg)

**缺点**：  
标记清除法的最大弊端就是在整个 GC 期间需要 STW，将整个程序暂停。这种全程 STW 的 GC 算法在追求高性能的今天，很难被接受。

---

### v1.5 - 三色标记法

#### 三色标记法

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.004.jpeg)

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.005.jpeg)

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.006.jpeg)

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.007.jpeg)

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.008.jpeg)

对于上述的三色标记法来讲，仍然需要依赖 STW。因为如果不暂停程序，程序的逻辑改变对象引用关系，这种动作如果在标记阶段做了修改，会影响标记结果的正确性。

#### 举例场景：

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.009.jpeg)

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.010.jpeg)

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.011.jpeg)

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.012.jpeg)

张三道友陷入了沉思，质疑小道哥说：  
“等等，普通的标记清除法，需要 STW，好家伙，你这一顿操作猛如虎，咋还是需要 STW，性能上没有什么优化啊…”

---

其实总结来看，在三色标记法的过程中对象丢失，需要同时满足下面两个条件：

- 条件一：白色对象被黑色对象引用
- 条件二：灰色对象与白色对象之间的可达关系遭到破坏

看来只要把上面两个条件破坏掉一个，就可以保证对象不丢失，所以我们的 Golang 团队就提出了两种破坏条件的方式：强三色不变式和弱三色不变式。

#### 两种不变式

##### 强三色不变式

规则：不允许黑色对象引用白色对象

破坏了条件一：白色对象被黑色对象引用

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.013.png)

解释：如果一个黑色对象不直接引用白色对象，那么就不会出现白色对象扫描不到，从而被当做垃圾回收掉的尴尬。

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.014.png)

##### 弱三色不变式

规则：黑色对象可以引用白色对象，但是白色对象的上游必须存在灰色对象

破坏了条件二：灰色对象与白色对象之间的可达关系遭到破坏

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.015.png)

解释：如果一个白色对象的上游有灰色对象，则这个白色对象一定可以扫描到，从而不被回收

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.016.jpeg)

---

### 屏障机制

Golang 团队遵循上述两种不变式提到的原则，分别提出了两种实现机制：插入写屏障和删除写屏障。

#### 插入写屏障

规则：当一个对象引用另外一个对象时，将另外一个对象标记为灰色。

满足：强三色不变式。不会存在黑色对象引用白色对象

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.017.png)

这里需要注意一点，插入屏障仅会在堆内存中生效，不对栈内存空间生效，这是因为 Go 在并发运行时，大部分的操作都发生在栈上，函数调用会非常频繁。数十万 goroutine 的栈都进行屏障保护自然会有性能问题。

下面我们看看插入写屏障机制，在插入写屏障机制下是如何保护对象不丢失的。

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.018.jpeg)

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.019.jpeg)

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.020.jpeg)

可以发现，对象 3 在插入写屏障机制下，得到了保护，但是由于栈上的对象没有插入写机制，在扫描完成后，仍然可能存在栈上的白色对象被黑色对象引用，所以在最后需要对栈上的空间进行 STW，防止对象误删除。如下所示：

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.021.jpeg)

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.022.jpeg)

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.023.jpeg)

对于插入写屏障来讲，道友们需记住，插入写屏障最大的弊端就是，在一次正常的三色标记流程结束后，需要对栈上重新进行一次 STW，然后再 rescan 一次。

#### 删除写屏障

规则：在删除引用时，如果被删除引用的对象自身为灰色或者白色，那么被标记为灰色。

满足：弱三色不变式。灰色对象到白色对象的路径不会断

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.024.png)

解释：白色对象始终会被灰色对象保护

下面我们看看在删除写屏障机制下是如何保护对象不丢失的。

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.025.jpeg)

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.026.jpeg)

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.027.jpeg)

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.028.jpeg)

但是引入删除写屏障，有一个弊端，就是一个对象的引用被删除后，即使没有其他存活的对象引用它，它仍然会活到下一轮。如此一来，会产生很多的冗余扫描成本，且降低了回收精度，举例来讲。

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.029.jpeg)

---

### 小结

从上述示例来看，插入写屏障机制和删除写屏障机制中任一机制均可保护对象不被丢失。在 v1.5 的版本中采用的是插入写机制实现。

#### 对比插入写屏障和删除写屏障：

- **插入写屏障**：
  - 插入写屏障哪里都好，就是栈上的操作管不到，所以最后需要对栈空间进行 STW 保护，然后 rescan 保证引用的白色对象存活。
- **删除写屏障**：
  - 在 GC 开始时，会扫描记录整个栈做快照，从而在删除操作时，可以拦截操作，将白色对象置为灰色对象。
  - 回收精度低。

---

### v1.8 - 混合写屏障机制

讲到这里，如果是你，你会怎么做呢？当然是取其精华，去其糟粕啦。没错，Golang 团队，正是结合了这两点，在 v1.8 版本下引入了混合写屏障机制。下面我们看下混合屏障机制的核心定义：

- GC 刚开始的时候，会将栈上的可达对象全部标记为黑色。
- GC 期间，任何在栈上新创建的对象，均为黑色。

上面两点只有一个目的，将栈上的可达对象全部标黑，最后无需对栈进行 STW，就可以保证栈上的对象不会丢失。有人说，一直是黑色的对象，那么不就永远清除不掉了么，这里强调一下，标记为黑色的是可达对象，不可达的对象一直会是白色，直到最后被回收。

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.030.png)

- 堆上被删除的对象标记为灰色
- 堆上新添加的对象标记为灰色

下面我们看看混合写屏障机制的示例图。

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.031.jpeg)

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.032.jpeg)

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.033.jpeg)

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.034.jpeg)

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.035.jpeg)

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.036.jpeg)

张三道友看到这里，提出了一个问题，万一栈上的对象 1 引用了堆上的对象 8，由于不触发混合写屏障机制，那对象 8 一直是白色的，最后不就被垃圾回收走了么，谁来保护它？

这个问题很好，私下里很多粉丝也咨询过我，这里统一解释一下，这个情况是不会发生的，因为一个对象之所以可以引用另外一个对象，它的前提是需要另外一个对象可达，图中的 8 号显然是不可达的，所以不会出现这种情况。

那又有道友问了，为什么 1 号对象可以引用 7 号对象呢？这是因为 1 号对象在引用 7 号对象的时候，对象 7 是在对象 6 的下游，本身是可达。

![](go/Aspose.Words.ef84b668-0ad1-454c-aafe-be829565d328.037.jpeg)

---

## 总结

- Golang v1.3 之前采用传统采取标记-清除法，需要 STW，暂停整个程序的运行。
- 在 v1.5 版本中，引入了三色标记法和插入写屏障机制，其中插入写屏障机制只在堆内存中生效。但在标记过程中，最后需要对栈进行 STW。
- 在 v1.8 版本中结合删除写屏障机制，推出了混合屏障机制，屏障限制只在堆内存中生效。避免了最后节点对栈进行 STW 的问题，提升了 GC 效率。
